# Data normalization 
#load the following packages 
library(DESeq2)
library(stringr)
library(readr)
library(tidyr)
library(data.table)
library(limma)             
library(dplyr)
#set working directory 
setwd("C:/Users/desqz2/Desktop/ARPM")
dat<-read.csv("GSE172367_count2_ave2_RV_normalizedxCV5.csv", row.names = 1)
dim(dat)
design<-read.csv("GSE121212_cout_NL_H_dup_cout.csv", row.names = 1)
#Normalize Counts with DESeq
dds <- DESeqDataSetFromMatrix(dat ,dt , design = ~Type)
dim(dds) 
dds <- DESeq(dds)
a <- varianceStabilizingTransformation(dds)
b <- getVarianceStabilizedData(dds)
b1 <- rowVars(b)
summary(b1)
q00_wpn <- quantile( rowVars(b)) 
expr_normalized <- b[ b1 > q00_wpn, ]
expr_normalized
xx<-expr_normalized
dim(xx)
#save normalized exp_value
write.csv(expr_normalized, "GSE121212_normalized_NL_HL.csv")
dat2<-read.csv("GSE172367_count2_ave2_RV_normalizedxCV5.csv", row.names = 1)
dt2$CV<-apply(dt2,1, function(x) sd(x) / mean(x) * 100) # CV of each gene
#write.csv(dt2, "GSE121212_Normalized_VSTCV.CV.csv")
# Select hypervariable genes based CV grater than 4 % 
 dat3<-dat2[dat2$CV > 4,]

#WGCNA analysis 
 dat<-read.csv("dat3.csv", row.names = 1)
 dim(dat3)
 input_mat = t(dat3)
 # Choose a set of soft threshold parameters
  powers = c(c(1:10), seq(from = 12, to=20, by=2))
 
 sft = pickSoftThreshold(input_mat, powerVector = powers, verbose = 5) 
 # Scale-free topology fit index as a function of the soft-thresholding power
 #pdf(file = "2-n-sft.pdf", width = 9, height = 5);
 par(mfrow = c(1,2));
 cex1 = 0.9;
 plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
      xlab="Soft Threshold (power)",ylab="Scale Free Topology Model Fit,signed R^2",type="n",
      main = paste("Scale independence"));
 text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
      labels=powers,cex=cex1,col="red");
 # this line corresponds to using an R^2 cut-off of h
 abline(h=0.85,col="red") 
 # Mean connectivity as a function of the soft-thresholding power
 plot(sft$fitIndices[,1], sft$fitIndices[,5],
      xlab="Soft Threshold (power)",ylab="Mean Connectivity", type="n",
      main = paste("Mean connectivity")) 
 text(sft$fitIndices[,1], sft$fitIndices[,5], labels=powers, cex=cex1,col="red")
 
 
 picked_power = 5
 temp_cor <- cor       
 cor <- WGCNA::cor         
 netwk <- blockwiseModules(input_mat,
                           
                           power = picked_power,                
                           networkType = "signed",
                           deepSplit = 2,
                           pamRespectsDendro = F,
                           minModuleSize = 50,
                           maxBlockSize = 5000,
                           reassignThreshold = 0,
                           mergeCutHeight = 0.25,
                           saveTOMs = T,
                           saveTOMFileBase = "ER",
                           numericLabels = T,
                           verbose = 3)
 
 
 
 
 module_eigengenes <- netwk$MEs
 netwk$MEs
 # Print out a preview
 head(module_eigengenes)
 
 df<-module_eigengenes
 write.csv(df,"module_eigengeneMerge.csv")
 
 sizeGrWindow(12, 9)
 # Convert labels to colors for plotting
 mergedColors = labels2colors(netwk$colors)
 plotDendroAndColors(
   netwk$dendrograms[[1]],
   mergedColors[netwk$blockGenes[[1]]],
   "Module colors",
   dendroLabels = FALSE,
   hang = 0.03,
   addGuide = TRUE,
   guideHang = 0.05 )
 
  netwk$colors[netwk$blockGenes[[1]]]
 table(netwk$colors)
 module_df <- data.frame(
   gene_id = names(netwk$colors),
   colors = labels2colors(netwk$colors)
 )
 
 module_df[1:5,]
 module_df
 write.csv(module_df, "modGSE107361.csv")
 
 
 
 
 
 # Get Module Eigengenes per cluster
 MEs0 <- moduleEigengenes(input_mat, mergedColors)$eigengenes
 
 # Reorder modules so similar modules are next to each other
 MEs0 <- orderMEs(MEs0)
 module_order = names(MEs0) %>% gsub("ME","", .)
 
 module_order
 
 
 MEs0
 write.csv(MEs0, "MEs0_GSEMerge.csv")
 
 # Get Module Eigengenes per cluster
 MEs0 <- moduleEigengenes(input_mat, mergedColors)$eigengenes
 
 
 
 
 MEList = moduleEigengenes(input_mat, colors = mergedColors)
 MEs = MEList$eigengenes
 plotEigengeneNetworks(MEs0, "", marDendro = c(0,4,1,2), marHeatmap = c(3,4,1,2))
 
 #**************************************************
 # Define numbers of genes and samples
 nGenes = ncol(input_mat);
 nSamples = nrow(input_mat);
 # Recalculate MEs with color labels
 MEs0 = moduleEigengenes(input_mat, mergedColors)$eigengenes
 MEs = orderMEs(MEs0)
 dim(MEs)
 MEs$MEgreen
 
 # Read clincial traits of asthma and control subjects
 bac_traits = read.csv("GSE130588_clinicalData2.csv", row.names = 1)
 bac_traits = read.csv("GSE130588_clinicalData.csv", row.names = 1)
 bac_traits = read.csv("GSE130588_clinicalData3.csv", row.names = 1)
 bac_traits = read.csv("GSE121212Design.csv", row.names = 1)
 
 bac_traits = read.csv("LS_NLGSE121212clinical.csv", row.names = 1)
 bac_traits = read.csv("LN_HGSE121212clinical.csv", row.names = 1)
 bac_traits = read.csv("LS_H_GSE121212clinical.csv", row.names = 1)
 bac_traits = read.csv("GSE130588_clinicalData3x2.csv", row.names = 1)
 bac_traits = read.csv("GSE121212Designx.csv", row.names = 1)
 bac_traits = read.csv("mergeclinical8.csv", row.names = 1)
 bac_traits = read.csv("GSE107361_MatrixDesignx.csv", row.names = 1)
 
 bac_traits[,-1] # for CSV
 bac_traits
 rownames(bac_traits)
 rownames(MEs)
 dd<-rownames(MEs)
 write.csv(dd, "GSE121212_MEs.csv")
 
 # sample names should be consistent in eigen genes and traits !!!!
 bac_traits = bac_traits[match(rownames(MEs), rownames(bac_traits)), ]
 
 table(rownames(MEs) == rownames(bac_traits))
 # Calculate pearson correlation coefficients between module eigen-genes and traits
 moduleTraitCor = cor(MEs, bac_traits, use = "p");
 moduleTraitPvalue = corPvalueStudent(moduleTraitCor, nSamples);
 moduleTraitCor 
 moduleTraitPvalue
 
 xx2<-moduleTraitPvalue
 moduleTraitCor
 xx3<-moduleTraitCor
 write.csv(xx3,"module___mGSE107361.csv" )
 
 write.csv(xx2,"module___merge.csv" )
 
 
 sizeGrWindow(10,6)
 # Will display correlations and their p-values
 textMatrix = paste(signif(moduleTraitCor, 1), "\n(",
                    signif(moduleTraitPvalue, 1), ")", sep = "");
 dim(textMatrix) = dim(moduleTraitCor)
 par(mar = c(6, 8.5, 3, 3));
 # Display the correlation values within a heatmap plot
 labeledHeatmap(Matrix = moduleTraitCor,
                xLabels = names(bac_traits),
                yLabels = names(MEs),
                ySymbols = names(MEs),
                colorLabels = FALSE,
                colors = greenWhiteRed(50),
                textMatrix = textMatrix,
                setStdMargins = FALSE,
                cex.text = 0.5,
                zlim = c(-1,1),
                main = paste("Module-trait relationships"))
 
 
 
 
 # Gene Significance and Module Membership
 
 # Define variable Lesional containing from input-dat
 Lesional = as.data.frame(bac_traits$Lesional);
 names(Lesional) = "Lesional"
 # names (colors) of the modules
 modNames = substring(names(MEs), 3)
 modNames
 Lesional
 geneModuleMembership = as.data.frame(cor(input_mat, MEs, use = "p"));
 MMPvalue = as.data.frame(corPvalueStudent(as.matrix(geneModuleMembership), nSamples));
 names(geneModuleMembership) = paste("MM", modNames, sep="");
 names(MMPvalue) = paste("p.MM", modNames, sep="");
 geneTraitSignificance = as.data.frame(cor(input_mat, Lesional, use = "p"));
 GSPvalue = as.data.frame(corPvalueStudent(as.matrix(geneTraitSignificance), nSamples));
 names(geneTraitSignificance) = paste("GS.", names(Lesional), sep="");
 names(GSPvalue) = paste("p.GS.", names(Lesional), sep="");
 
 MEs$MEblue
 module = "blue"
 column = match(module, modNames);
 column
 
 moduleGenes = mergedColors==module;
 moduleGenes
 
 sizeGrWindow(7, 7);
 par(mfrow = c(1,1));
 verboseScatterplot(abs(geneModuleMembership[moduleGenes, column]),
                    abs(geneTraitSignificance[moduleGenes, 1]),
                    xlab = paste("Module Membership in", module, "module"),
                    ylab = "Gene significance for AD Status",
                    main = paste("Module membership vs. gene significance\n"),
                    cex.main = 0.9, cex.lab = 1, cex.axis = 1, col = module) 
 
 
# Machine learning based Feature selection 
library(glmnet)
library(Boruta)
library(caret) 
 
 dat<-read.csv("GSE67472.DEGgene3665x.csv", row.names = 1)
 dat$Type
 y<-dat$Type
 x<-model.matrix(y~., dat[,-1:-2])
  cv.fit <- cv.glmnet(x,y, family="binomial", alpha= 1)
 plot(cv.fit)
 fit <- glmnet(x,y, family = "binomial", alpha = 1)
 plot(fit)
 cv.fit$lambda.min
 
 Coefficients <- coef(fit, s = fit$lambda.min)
 Active.Index <- which(Coefficients != 0)
 Active.Coefficients <- Coefficients[Active.Index]
 coef(cv.fit, s = "lambda.min")
 # Boruta Algorithms 
 set.seed(123)
 # Run Boruta Algorithm
 boruta <- Boruta(Type~., data = dat, doTrace = 2)
 print(boruta)
 plot(boruta)
 xx<-attStats(boruta)
# List of final selected Key variables/genes
 finalvars = getSelectedAttributes(boruta, withTentative = F)
 finalvars
 # RF algorithm
 Control <- trainControl(method = "cv",number = 5)
  # run the RFE algorithm
 control <- rfeControl(functions=rfFuncs, method="cv", number=5)
  results <- rfe(dat[,2:726], dat[,1], sizes=c(1:726), rfeControl=control)
 print(results)
 # list the chosen features
 predictors(results)
 
 dim(dat)
 #RF
 x <- dat[,2:726]
 y <- dat[,1]
 control <- trainControl(method="repeatedcv", number=10, repeats=3)
 seed <- 7
 metric <- "Accuracy"
 set.seed(seed)
 mtry <- sqrt(ncol(x))
 tunegrid <- expand.grid(.mtry=mtry)
 rf_default <- train(Type~., data=dat, method="rf", metric=metric, tuneGrid=tunegrid, trControl=control)
 print(rf_default)
 
 # Bar plots for the coefficients of each methods 
 library(ggpubr)
 library(ggplot2)
 library(magrittr)
 library(dplyr)
 library(ggpubr)
 
 
 
 
 
 
 
 
 
 
 
 
 
 
# MLeval: Machine Learning Model Evaluation
 library(tidymodels)
 library(MLeval)
 library(caret)

 # Run algorithms using 5-fold cross validation
  control <- trainControl(method="LOOCV", 
                         number=5, 
                         savePredictions = "final", 
                         search = "grid", 
                         classProbs = TRUE)
 
 control <- trainControl(method="cv", 
                         number=5, 
                         repeats = 5, 
                         savePredictions = "final", 
                         search = "grid", 
                         classProbs = TRUE)

 metric <- "Accuracy"
 dat$Type<-as.factor(dat$Type)
 dim(dat)


 
 
 
 
 
 
 
 set.seed(7)
 fit.svm <- train(Type ~ .,data=dat10, method="svmRadial", metric=metric, trControl=control, verbose = FALSE, tuneLength = 2)
 set.seed(7)
 fit.rf <- train(Type ~ .,data=dat10, method="rf", metric=metric, trControl=control, verbose = FALSE)
 # plot
 models <- list( SVM = fit.svm,
                 RF = fit.rf)
 models <- models[order(names(models))]
 
 evalm(
   models,
   gnames = names(models),
   rlinethick = 0.8, fsize = 8, plots = "r"
 )
 
 set.seed(7)
 fit.svm <- train(Type ~ .,data=dat1, method="svmRadial", metric=metric, trControl=control, verbose = FALSE, tuneLength = 2)
 set.seed(7)
 fit.rf <- train(Type ~ .,data=dat15, method="rf", metric=metric, trControl=control, verbose = FALSE)
 # plot
 models <- list( SVM = fit.svm,
                 RF = fit.rf)
 models <- models[order(names(models))]
 
 evalm(
   models,
   gnames = names(models),
   rlinethick = 0.8, fsize = 8, plots = "r"
 )
 
 set.seed(7)
 fit.svm <- train(Type ~ .,data=dat20, method="svmRadial", metric=metric, trControl=control, verbose = FALSE, tuneLength = 2)
 set.seed(7)
 fit.rf <- train(Type ~ .,data=dat20, method="rf", metric=metric, trControl=control, verbose = FALSE)
 # plot
 models <- list( SVM = fit.svm,
                 RF = fit.rf)
 models <- models[order(names(models))]
 
 evalm(
   models,
   gnames = names(models),
   rlinethick = 0.8, fsize = 8, plots = "r"
 )
 set.seed(7)
 fit.svm <- train(Type ~ .,data=dat25, method="svmRadial", metric=metric, trControl=control, verbose = FALSE, tuneLength = 2)
 set.seed(7)
 fit.rf <- train(Type ~ .,data=dat25, method="rf", metric=metric, trControl=control, verbose = FALSE)
 # plot
 models <- list( SVM = fit.svm,
                 RF = fit.rf)
 models <- models[order(names(models))]
 
 evalm(
   models,
   gnames = names(models),
   rlinethick = 0.8, fsize = 8, plots = "r"
 )
 
 set.seed(7)
 fit.svm <- train(Type ~ .,data=dat30, method="svmRadial", metric=metric, trControl=control, verbose = FALSE, tuneLength = 2)
 set.seed(7)
 fit.rf <- train(Type ~ .,data=dat30, method="rf", metric=metric, trControl=control, verbose = FALSE)
 # plot
 models <- list( SVM = fit.svm,
                 RF = fit.rf)
 models <- models[order(names(models))]
 
 evalm(
   models,
   gnames = names(models),
   rlinethick = 0.8, fsize = 8, plots = "r"
 )
 set.seed(7)
 fit.svm <- train(Type ~ .,data=datall, method="svmRadial", metric=metric, trControl=control, verbose = FALSE, tuneLength = 2)
 set.seed(7)
 fit.rf <- train(Type ~ .,data=datall, method="rf", metric=metric, trControl=control, verbose = FALSE)
 # plot
 plot <- evalm(list(fit.svm, fit.rf),
               gnames = c("SVM", "RF"),
               rlinethick=0.8, fsize=8, plots='r')
 
 
 models <- list( SVM = fit.svm,
                 RF = fit.rf)
 models <- models[order(names(models))]
 
 evalm(
   models,
   gnames = names(models),
   rlinethick = 0.8, fsize = 8, plots = "r"
 )
 
 # top features based RF
 
 datM1<-datM[,1:854]
 datD1<-datD[,1:3565]
 datB1<-datB[,1:31]
 datL1<-datL[,1:31]
 datRF1<-datRF[,1:31]
 datRFE1<-datRFE[,1:31]
 
 
 datB1<-datB[,1:11]
 datL1<-datL[,1:11]
 datRF1<-datRF[,1:11]
 datRFE1<-datRFE[,1:11]
 
 
 set.seed(7)
 fit.rfM1 <- train(Type ~ .,data=datM1, method="rf", metric=metric, trControl=control, verbose = FALSE)
 fit.rfD1 <- train(Type ~ .,data=datD1, method="rf", metric=metric, trControl=control, verbose = FALSE)
 fit.rfB1 <- train(Type ~ .,data=datB1, method="rf", metric=metric, trControl=control, verbose = FALSE)
 fit.rfL1 <- train(Type ~ .,data=datL1, method="rf", metric=metric, trControl=control, verbose = FALSE)
 fit.rfRF1 <- train(Type ~ .,data=datRF1, method="rf", metric=metric, trControl=control, verbose = FALSE)
 fit.rfRFE1 <- train(Type ~ .,data=datRFE1, method="rf", metric=metric, trControl=control, verbose = FALSE)
 #fit.rfall <- train(Type ~ .,data=datall, method="rf", metric=metric, trControl=control, verbose = FALSE)
 
 
 set.seed(7)
 fit.rfM1 <- train(Type ~ .,data=datM1, method="svmRadial", metric=metric, trControl=control, verbose = FALSE)
 fit.rfD1 <- train(Type ~ .,data=datD1, method="svmRadial", metric=metric, trControl=control, verbose = FALSE)
 fit.rfB1 <- train(Type ~ .,data=datB1, method="svmRadial", metric=metric, trControl=control, verbose = FALSE)
 fit.rfL1 <- train(Type ~ .,data=datL1, method="svmRadial", metric=metric, trControl=control, verbose = FALSE)
 fit.rfRF1 <- train(Type ~ .,data=datRF1, method="svmRadial", metric=metric, trControl=control, verbose = FALSE)
 fit.rfRFE1 <- train(Type ~ .,data=datRFE1, method="svmRadial", metric=metric, trControl=control, verbose = FALSE)
 #fit.rfall <- train(Type ~ .,data=datall, method="rf", metric=metric, trControl=control, verbose = FALSE)
 
 
 set.seed(7)
 fit.rfL1r <- train(Type ~ .,data=datL1, method="rf", metric=metric, trControl=control, verbose = FALSE)
 fit.rfRF1r <- train(Type ~ .,data=datRF1, method="rf", metric=metric, trControl=control, verbose = FALSE)
 fit.rfL1s <- train(Type ~ .,data=datL1, method="svmRadial", metric=metric, trControl=control, verbose = FALSE)
 fit.rfRF1s <- train(Type ~ .,data=datRF1, method="svmRadial", metric=metric, trControl=control, verbose = FALSE)
 
 
 
 models <- list( Allmodulegenes = fit.rfM1,
                 AllDEGs = fit.rfD1,
                 Borutagenes = fit.rfB1,
                 Lassogenes = fit.rfL1,
                 RFgenenes = fit.rfRF1,
                 RFEgenes = fit.rfRFE1 )
 models <- models[order(names(models))]
 
 evalm(
   models,
   gnames = names(models),
   rlinethick = 0.8, fsize = 8, plots = "r"
 )
 
 
 models <- list(Lassogenes = fit.rfL1,
                RFgenenes = fit.rfRF1 )
 models <- models[order(names(models))]
 
 evalm(
   models,
   gnames = names(models),
   rlinethick = 0.8, fsize = 8, plots = "r"
 )
 
 
 models <- list(Lassogenes_SVM = fit.rfL1s,
                RFgenenes_SVM = fit.rfRF1s,
                Lassogenes_RF = fit.rfL1r,
                RFgenenes_RF = fit.rfRF1r)
 models <- models[order(names(models))]
 
 evalm(
   models,
   gnames = names(models),
   rlinethick = 0.8, fsize = 8, plots = "r"
 )
 
 
 
 
 
 
